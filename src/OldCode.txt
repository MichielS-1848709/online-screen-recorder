import React, { MutableRefObject, useRef, useState } from "react";

// https://github.com/muaz-khan/RecordRTC/blob/eb16816757121bcfcbd198d394d4d47459cadd22/simple-demos/video-plus-screen-recording.html

/**
 * @author Michiel Swaanen
 */
type StreamState = {
  access: boolean,
  person: MediaRecorder | null
  recorder: MediaRecorder | null,
  error: string
}

type RecordingState = {
  active: boolean,
  available: boolean,
  screen: MediaStream | null
  person: MediaStream | null
}

function getSupportedMimeTypes() {
  const VIDEO_TYPES = [
    "webm",
    "ogg",
    "mp4",
    "x-matroska"
  ];
  const VIDEO_CODECS = [
    "vp9",
    "vp9,opus",
    "vp9.0",
    "vp8,opus",
    "vp8",
    "vp8.0",
    "avc1",
    "av1",
    "h265",
    "h.265",
    "h264",
    "h.264",
    "opus",
  ];

  const supportedTypes: string[] = [];
  VIDEO_TYPES.forEach((videoType) => {
    const type = `video/${videoType}`;
    VIDEO_CODECS.forEach((codec) => {
      const variations = [
        `${type};codecs=${codec}`,
        `${type};codecs:${codec}`,
        `${type};codecs=${codec.toUpperCase()}`,
        `${type};codecs:${codec.toUpperCase()}`,
        `${type}`
      ]
      variations.forEach(variation => {
        if(MediaRecorder.isTypeSupported(variation))
          supportedTypes.push(variation);
      })
    });
  });
  return supportedTypes;
}

function App() {
  const [stream, setStream] = useState<StreamState>({
    access: false,
    person: null,
    recorder: null,
    error: ""
  });

  const [recording, setRecording] = useState<RecordingState>({
    active: false,
    available: false,
    screen: null,
    person: null
  });

  // const chunks: MutableRefObject<Blob[]> = useRef([]);
  // const personChunks: MutableRefObject<Blob[]> = useRef([]);

  const getAccess = async () => {
    try {

      // Ask microphone permission
      const personStream: MediaStream = await navigator.mediaDevices.getUserMedia({audio: true, video: true});

      // Ask screen share permission
      //@ts-ignore
      const screenStream: MediaStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
      const supportedMimeTypes = getSupportedMimeTypes();
      const mimeType = supportedMimeTypes[0];
      console.log('Optimal Mimetype:', mimeType)
      const personRecorder: MediaRecorder = new MediaRecorder(personStream, {
        audioBitsPerSecond: 128000,
        videoBitsPerSecond: 2500000,
        mimeType: mimeType
      });

      const screenRecorder: MediaRecorder = new MediaRecorder(screenStream, {
        audioBitsPerSecond: 128000,
        videoBitsPerSecond: 2500000,
        mimeType: mimeType
      });

      screenRecorder.start();
      personRecorder.start();

      screenRecorder.onstart = () => setRecording({ active: true, available: false, screen: null, person: null });

      // screenRecorder.ondataavailable = (e: BlobEvent) => chunks.current.push(e.data);
      // personRecorder.ondataavailable = (e: BlobEvent) => personChunks.current.push(e.data);

      screenRecorder.onstart = () => {
        //@ts-ignore
        document.querySelector("#webcam").srcObject = personStream
        setRecording({
          active: true,
          available: false,
          screen: null,
          person: null
        })
      }

      screenRecorder.onstop = () => {
        personRecorder.stop();
        console.log('Stopped');

        // const screen = URL.createObjectURL(chunks.current[0]);
        // const person = URL.createObjectURL(personChunks.current[0]);
        // chunks.current = [];
        // personChunks.current = [];

        setRecording({
          active: false,
          available: true,
          screen: screenStream,
          person: personStream
        });
      };

      setStream({
        access: true,
        person: personRecorder,
        recorder: screenRecorder,
        error: ""
      });
    } catch (e) {
      console.log('Crashed')
      console.log(e);
    }
  }

  const videos = document.getElementsByTagName("video");

  if(videos.length > 0) {
    videos[0].srcObject = recording.screen;
  }

  return (
    <div>
      { stream.access ? (
        <div>
          <video autoPlay={true} height={360} width={540} id="screen-recording" />
          <video autoPlay={true} height={360} width={540} id="webcam" />
          <button disabled={recording.active} onClick={ () => !recording.active && stream.recorder!.start() }>Start recording</button>
          <button disabled={!recording.active} onClick={ () => stream.recorder!.stop() }>Stop recording</button>
          {recording.available && <div>
            <video height={360} width={540} controls={true} id={"screen-recording"}>
              {/*<source src={recording.screen}/>*/}
            </video>
            <video height={360} width={540} controls={true} id={"person-recording"}>
              {/*<source src={recording.person}/>*/}
            </video>
          </div>}
        </div>
      ) : (
        <button onClick={ getAccess }>Give Access</button>
      ) }
    </div>
  )
}

export default App;